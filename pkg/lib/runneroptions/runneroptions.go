// Copyright 2019,2026 The kpt Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package runneroptions holds options for the function runtime
package runneroptions

import (
	"context"
	"fmt"
	"strings"
)

const (
	FuncGenPkgContext = "builtins/gen-pkg-context"
	GHCRImagePrefix   = "ghcr.io/kptdev/krm-functions-catalog/"
)

// ImageResolveFunc is the type for a function that can resolve a partial image to a (more) fully-qualified name
type ImageResolveFunc func(ctx context.Context, image string) (string, error)

type RunnerOptions struct {
	// ImagePullPolicy controls the image pulling behavior before running the container.
	ImagePullPolicy ImagePullPolicy

	// when set to true, function runner will set the package path annotation
	// on resources that do not have it set. The resources generated by
	// functions do not have this annotation set.
	SetPkgPathAnnotation bool

	DisplayResourceCount bool

	// allowExec determines if function binary executable are allowed
	// to be run during pipeline execution. Running function binaries is a
	// privileged operation, so explicit permission is required.
	AllowExec bool

	// AllowNetwork specifies if container based functions are allowed
	// to access network during pipeline execution. Accessing network is
	// considered a privileged operation (and makes render operation non-hermetic),
	// so explicit permission is desired.
	AllowNetwork bool

	// allowWasm determines if function wasm are allowed to be run during pipeline
	// execution. Running wasm function is an alpha feature, so it needs to be
	// enabled explicitly.
	AllowWasm bool

	// ResolveToImage will resolve a partial image to a fully-qualified one
	ResolveToImage ImageResolveFunc
}

func (opts *RunnerOptions) InitDefaults(defaultImagePrefix string) {
	opts.ImagePullPolicy = IfNotPresentPull
	opts.ResolveToImage = opts.ResolveToImageForCLIFunc(defaultImagePrefix)
}

// ResolveToImageForCLIFunc returns a func that converts the KRM function short path to the full image url.
// If the function is a catalog function, it prepends `prefix`, e.g. "set-namespace:v0.1" --> prefix + "set-namespace:v0.1".
// A "/" is appended to `prefix` if it is not an empty string and does not end with a "/".
func (opts *RunnerOptions) ResolveToImageForCLIFunc(prefix string) func(_ context.Context, image string) (string, error) {
	prefix = strings.TrimSuffix(prefix, "/")
	if prefix == "" {
		return func(_ context.Context, image string) (string, error) {
			return image, nil
		}
	}
	return func(_ context.Context, image string) (string, error) {
		if !strings.Contains(image, "/") {
			return fmt.Sprintf("%s/%s", prefix, image), nil
		}
		return image, nil
	}
}

type SingleLineFormatter struct {
	Title     string   // Label for the output
	Lines     []string // Lines to be joined
	UseQuote  bool     // Whether to quote each line
	Separator string   // Separator between lines (e.g., comma, space)
}

func (sf *SingleLineFormatter) String() string {
	strInterpolator := "%s"
	if sf.UseQuote {
		strInterpolator = "%q"
	}

	var formattedLines []string
	for _, line := range sf.Lines {
		line = strings.ReplaceAll(line, "\n", " ")
		line = strings.TrimSpace(line)
		formattedLines = append(formattedLines, fmt.Sprintf(strInterpolator, line))
	}

	return fmt.Sprintf("%s: %s", sf.Title, strings.Join(formattedLines, sf.Separator))
}
