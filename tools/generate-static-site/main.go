// Copyright 2023 The kpt Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"context"
	"embed"
	"flag"
	"fmt"
	"html/template"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"golang.org/x/net/html"

	"github.com/igorsobreira/titlecase"
	"github.com/yuin/goldmark"
	meta "github.com/yuin/goldmark-meta"
	"github.com/yuin/goldmark/ast"
	gast "github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/extension"
	"github.com/yuin/goldmark/parser"
	mdhtml "github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/text"
	"github.com/yuin/goldmark/util"
	"k8s.io/klog/v2"
)

//go:embed templates/*
var templates embed.FS

const markdownExtension = ".md"
const introPage = "00.md"

var pagePrefix = regexp.MustCompile(`^\d\d-?`)

func main() {
	if err := run(context.Background()); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

func run(ctx context.Context) error {
	srcBase := "site/"
	out := "websites/kpt.dev/"

	flag.Parse()

	md := goldmark.New(
		goldmark.WithExtensions(
			meta.Meta,         // ignore yaml metadata
			extension.Table,   // render tables
			&normalizeLinks{}, // .md -> .html
		),

		goldmark.WithRendererOptions(
			mdhtml.WithUnsafe(),
		),
	)

	// Build the sidebar
	sidebarMarkdown := ""
	{
		templatePath := "templates/sidebar_template.md.tmpl"

		t := template.Must(
			template.New(path.Base(templatePath)).
				Funcs(template.FuncMap{"bookLayout": getBookOutline}).
				ParseFS(templates, templatePath))

		var w bytes.Buffer
		fmt.Fprintf(&w, "<!--This sidebar was automatically generated by 'generate_site_sidebar'-->")
		err := t.Execute(&w, nil)
		if err != nil {
			return fmt.Errorf("running template: %w", err)
		}
		sidebarMarkdown = w.String()
	}
	sidebar := ""
	{
		var w bytes.Buffer
		if err := md.Convert([]byte(sidebarMarkdown), &w); err != nil {
			return fmt.Errorf("rendering markdown: %w", err)
		}
		sidebar = w.String()
	}

	// Go through and build pages for each markdown file
	var pages []*Page
	if err := filepath.WalkDir(srcBase, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		ext := filepath.Ext(path)

		b, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("reading file %q: %w", path, err)
		}
		src := string(b)

		srcPath := strings.TrimPrefix(path, srcBase)

		var page *Page

		ext = strings.ToLower(ext)
		switch ext {
		case ".html":
			page = &Page{
				URL:  "/" + srcPath,
				HTML: src,
			}

		case ".md":

			// Remove the hugo hide directives that we are using
			{
				re := regexp.MustCompile("(?ms)" + regexp.QuoteMeta("{{% hide %}}") + ".+?" + regexp.QuoteMeta("{{% /hide %}}"))
				src = re.ReplaceAllLiteralString(src, "")
				re2 := regexp.MustCompile("{{.*}}")
				src = re2.ReplaceAllLiteralString(src, "")
			}

			var htmlString string
			{
				var w bytes.Buffer
				mdContext := parser.NewContext()
				if err := md.Convert([]byte(src), &w, parser.WithContext(mdContext)); err != nil {
					return fmt.Errorf("rendering markdown: %w", err)
				}
				htmlString = w.String()

				metaData := meta.Get(mdContext)

				title := ""
				if v, ok := metaData["title"]; ok {
					title = v.(string)
				}

				if strings.HasPrefix(srcPath, "book/") {
					title = getBookPageTitle(srcPath)
					if title == "" {
						klog.Warningf("cannot parse book page title for %q", path)
					}
				}
				if title != "" {
					var w2 bytes.Buffer
					if err := md.Convert([]byte(title), &w2); err != nil {
						return fmt.Errorf("rendering markdown: %w", err)
					}

					htmlString = "<h1>" + w2.String() + "</h1>" + htmlString
				}
			}

			isCover := srcPath == "coverpage.md"
			if isCover {
				templateName := "templates/cover.html"
				template, err := templates.ReadFile(templateName)
				if err != nil {
					return fmt.Errorf("reading template %q: %w", templateName, err)
				}

				htmlString = strings.ReplaceAll(string(template), "<!--cover-->", htmlString)
			}

			{
				templateName := "templates/main.html"
				template, err := templates.ReadFile(templateName)
				if err != nil {
					return fmt.Errorf("reading template %q: %w", templateName, err)
				}

				htmlString = strings.ReplaceAll(string(template), "<!--main-->", htmlString)
			}
			{
				templateName := "templates/index.html"
				template, err := templates.ReadFile(templateName)
				if err != nil {
					return fmt.Errorf("reading template %q: %w", templateName, err)
				}

				htmlString = strings.ReplaceAll(string(template), "<!--index-->", htmlString)
			}

			if strings.Contains(htmlString, "<!--sidebar-->") {
				htmlString = strings.ReplaceAll(htmlString, "<!--sidebar-->", sidebar)
			}

			page = &Page{
				URL:  "/" + srcPath,
				HTML: htmlString,
			}

		default:
			klog.V(2).Infof("ignoring file with unknown extension %q", srcPath)
		}

		if page != nil {
			page.URL = strings.TrimSuffix(page.URL, "/README.md")
			page.URL = strings.TrimSuffix(page.URL, "/00.md")
			page.URL = strings.TrimSuffix(page.URL, ".md")

			pages = append(pages, page)
		}

		return nil
	}); err != nil {
		return err
	}

	for _, page := range pages {
		v := &PageVisitor{
			Page: page,
		}
		if err := v.postProcessHTML(); err != nil {
			return err
		}
	}

	for _, page := range pages {
		outURL := page.URL

		if !strings.HasSuffix(outURL, ".html") {
			outURL = outURL + ".html"
		}

		outPath := filepath.Join(out, strings.TrimPrefix(outURL, "/"))
		klog.V(2).Infof("writing file %v", outPath)

		outDir := filepath.Dir(outPath)
		if err := os.MkdirAll(outDir, 0755); err != nil {
			return fmt.Errorf("making directories %q: %w", outDir, err)
		}

		if err := os.WriteFile(outPath, []byte(page.HTML), 0644); err != nil {
			return fmt.Errorf("writing file %q: %w", outPath, err)
		}
	}

	return nil
}

func getBookOutline() string {
	sourcePath := "site/book"
	chapters := collectChapters(sourcePath)

	return getChapterBlock(chapters)
}

func collectChapters(source string) []chapter {
	chapters := make([]chapter, 0)
	chapterDirs, err := os.ReadDir(source)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}

	for _, dir := range chapterDirs {
		if dir.IsDir() {
			chapters = append(chapters, getChapter(dir.Name(), filepath.Join(source, dir.Name())))
		}
	}

	return chapters
}

func getChapter(chapterDirName string, chapterDirPath string) chapter {
	chapterBuilder := chapter{}

	// Split into chapter number and hyphenated name
	splitDirName := strings.SplitN(chapterDirName, "-", 2)
	chapterBuilder.Number = splitDirName[0]
	chapterBuilder.Name = titlecase.Title(strings.ReplaceAll(splitDirName[1], "-", " "))

	pageFiles, err := os.ReadDir(chapterDirPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}

	for _, pageFile := range pageFiles {
		if filepath.Ext(pageFile.Name()) == markdownExtension && pagePrefix.MatchString(pageFile.Name()) {
			chapterBuilder.Pages = append(chapterBuilder.Pages,
				getPage(pageFile.Name(), chapterBuilder.Name, chapterDirPath))
		}
	}

	return chapterBuilder
}

func getPage(pageFileName string, defaultName string, parentPath string) page {
	// Split into page number and hyphenated name.
	splitPageName := strings.SplitN(pageFileName, "-", 2)

	pageName := defaultName
	if pageFileName != introPage {
		// Strip page number and extension from file name.
		pageTitle := pagePrefix.ReplaceAll([]byte(pageFileName), []byte(""))
		pageName = titlecase.Title(strings.ReplaceAll(strings.ReplaceAll(string(pageTitle), ".md", ""), "-", " "))
	}

	p := page{
		Number: splitPageName[0],
		Name:   pageName,
		Path:   filepath.Join(parentPath, pageFileName),
	}

	if pageFileName == introPage {
		p.Path = parentPath
	}
	return p
}

func getChapterBlock(chapters []chapter) string {
	// Sort chapters in ascending order by chapter number.
	sort.Slice(chapters, func(i, j int) bool { return chapters[i].Number < chapters[j].Number })
	var sb strings.Builder
	for chapterIndex, chapterEntry := range chapters {
		chapterNumber := chapterIndex + 1
		for pageIndex, pageEntry := range chapterEntry.Pages {
			// Make path relative to site directory.
			path := strings.Replace(pageEntry.Path, "site/", "/", 1)

			// Print non-chapter intro pages as children of chapter intro page.
			if pageIndex == 0 {
				sb.WriteString(fmt.Sprintf("\t- [%d %s](%s)\n", chapterNumber, pageEntry.Name, path))
			} else {
				sb.WriteString(fmt.Sprintf("\t\t- [%d.%d %s](%s)\n", chapterNumber, pageIndex, pageEntry.Name, path))
			}
		}
	}
	return strings.TrimRight(sb.String(), "\n")
}

type chapter struct {
	Name   string
	Pages  []page
	Number string
}

type page struct {
	Name   string
	Path   string
	Number string
}

type normalizeLinks struct {
}

func (x *normalizeLinks) Extend(md goldmark.Markdown) {
	md.Parser().AddOptions(parser.WithASTTransformers(
		util.Prioritized(&normalizeLinksTransformer{}, 999),
	))
}

type normalizeLinksTransformer struct {
}

func (a *normalizeLinksTransformer) Transform(node *gast.Document, reader text.Reader, pc parser.Context) {
	a.visit(node, reader.Source())
}

func (a *normalizeLinksTransformer) visit(node gast.Node, src []byte) {
	switch node := node.(type) {
	case *ast.Link:
		dest := string(node.Destination)
		if strings.HasSuffix(dest, ".md") {
			dest = strings.TrimSuffix(dest, ".md")
		}
		node.Destination = []byte(dest)
	default:
		klog.V(2).Infof("node type %T not implmented", node)
	}

	pos := node.FirstChild()
	for pos != nil {
		a.visit(pos, src)
		pos = pos.NextSibling()
	}
}

type PageVisitor struct {
	Page *Page
}

func (v *PageVisitor) postProcessHTML() error {
	doc, err := html.Parse(bytes.NewReader([]byte(v.Page.HTML)))
	if err != nil {
		return fmt.Errorf("parsing html: %w", err)
	}

	var f func(*html.Node)
	f = func(n *html.Node) {
		if hasClassName(n, "sidebar-nav") {
			v.addActiveSidebar(n)
		}

		if hasClassName(n, "sidebar-nav") {
			addSidebarCollapsibility(n)
		}

		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(doc)

	var w bytes.Buffer
	if err := html.Render(&w, doc); err != nil {
		return fmt.Errorf("rendering html: %w", err)
	}
	v.Page.HTML = w.String()
	return nil
}

// Only show child pages for currently active page to avoid sidebar cluttering.
func (v *PageVisitor) addActiveSidebar(n *html.Node) {
	for _, li := range getElementsByTagName(n, "li") {
		for _, a := range getElementsByTagName(li, "a") {
			href := getAttr(a, "href")
			href = strings.TrimSuffix(href, "/")
			if href == v.Page.URL {
				addClass(li, "active")
			}
		}
	}
}

// Only show child pages for currently active page to avoid sidebar cluttering.
func addSidebarCollapsibility(n *html.Node) {
	uls := getElementsByTagName(n, "ul")

	for _, ul := range uls {
		if hasClassName(ul.Parent, "active") {
			continue
		}

		if len(getElementsByClassName(ul, "active")) == 0 {
			addClass(ul, "inactive")
		}
	}
}

func getElementsByTagName(el *html.Node, tagName string) []*html.Node {
	var ret []*html.Node
	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == tagName {
			ret = append(ret, n)
		}

		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(el)

	return ret
}

func getElementsByClassName(el *html.Node, className string) []*html.Node {
	var ret []*html.Node
	var f func(*html.Node)
	f = func(n *html.Node) {
		if hasClassName(n, className) {
			ret = append(ret, n)
		}

		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(el)

	return ret
}

func hasClassName(el *html.Node, className string) bool {
	for _, attr := range el.Attr {
		if attr.Key == "class" {
			tokens := strings.Split(attr.Val, " ")
			for _, token := range tokens {
				if token == className {
					return true
				}
			}
		}
	}
	return false
}

func getAttr(el *html.Node, attrKey string) string {
	for _, attr := range el.Attr {
		if attr.Key == attrKey {
			return attr.Val
		}
	}
	return ""
}

func addClass(el *html.Node, className string) {
	for _, attr := range el.Attr {
		if attr.Key == "class" {
			tokens := strings.Split(attr.Val, " ")
			for _, token := range tokens {
				if token == className {
					return
				}
			}
			tokens = append(tokens, className)
			attr.Val = strings.Join(tokens, " ")
			return
		}
	}
	el.Attr = append(el.Attr, html.Attribute{
		Key: "class",
		Val: className,
	})
}

type Site struct {
	Pages map[string]*Page
}

type Page struct {
	URL string

	HTML string
}

func getBookPageTitle(path string) string {
	path = strings.TrimPrefix(path, "book/")
	path = strings.TrimSuffix(path, ".md")
	path = strings.TrimSuffix(path, "/00")

	var heading string

	components := strings.Split(path, "/")
	for i, component := range components {
		tokens := strings.SplitN(component, "-", 2)
		if len(tokens) != 2 {
			return ""
		}

		n, err := strconv.Atoi(tokens[0])
		if err != nil {
			return ""
		}
		if heading != "" {
			heading += "."
		}
		heading = heading + fmt.Sprintf("%v", n)
		if i == len(components)-1 {
			return heading + " " + titlecase.Title(strings.ReplaceAll(tokens[1], "-", " "))
		}
	}

	return ""
}
